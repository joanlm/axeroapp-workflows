# Reusable workflow for building and releasing Axero Apps
# Called from app repositories to create releases
#
# Usage in app repo (.github/workflows/release.yml):
#
#   name: Release
#   on:
#     workflow_dispatch:
#       inputs:
#         version_bump:
#           type: choice
#           options: [patch, minor, major]
#     push:
#       branches: [main, master]
#
#   jobs:
#     release:
#       uses: joanlm/axeroapp-workflows/.github/workflows/build-axero-app.yml@main
#       with:
#         version_bump: ${{ inputs.version_bump || 'patch' }}
#       secrets:
#         cli_token: ${{ secrets.AXEROAPP_CLI_TOKEN }}
#
# Required secret:
#   AXEROAPP_CLI_TOKEN - GitHub PAT with repo access to joanlm/axeroapp-cli

name: Build Axero App

on:
  workflow_call:
    inputs:
      version_bump:
        description: 'Version bump type (patch, minor, major) - only used if manifest version unchanged'
        required: false
        default: 'patch'
        type: string
      app_path:
        description: 'Path to the app directory (default: repo root)'
        required: false
        default: '.'
        type: string
      cli_version:
        description: 'CLI version to use (default: latest)'
        required: false
        default: 'latest'
        type: string
      skip_build:
        description: 'Skip the build step (for apps without TypeScript/CSS)'
        required: false
        default: false
        type: boolean
      prerelease_label:
        description: 'Pre-release label (e.g., branch name). Empty = stable release'
        required: false
        default: ''
        type: string
    secrets:
      cli_token:
        description: 'GitHub token with access to axeroapp-cli private repo'
        required: true
    outputs:
      version:
        description: 'The version that was released'
        value: ${{ jobs.build.outputs.version }}
      release_url:
        description: 'URL of the created release'
        value: ${{ jobs.build.outputs.release_url }}
      is_prerelease:
        description: 'Whether this is a pre-release'
        value: ${{ jobs.build.outputs.is_prerelease }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for creating releases
    outputs:
      version: ${{ steps.version.outputs.version }}
      release_url: ${{ steps.release.outputs.url }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}

    steps:
      - name: Checkout app repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version comparison

      - name: Get latest release version
        id: latest
        run: |
          # Get the latest release tag, strip 'v' prefix
          LATEST=$(gh release view --json tagName -q '.tagName' 2>/dev/null || echo "v0.0.0")
          LATEST_VERSION="${LATEST#v}"
          echo "version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "Latest release: $LATEST_VERSION"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Read manifest version
        id: manifest
        run: |
          APP_PATH="${{ inputs.app_path }}"
          MANIFEST="$APP_PATH/manifest.json"

          if [ ! -f "$MANIFEST" ]; then
            echo "::error::manifest.json not found at $MANIFEST"
            exit 1
          fi

          VERSION=$(jq -r '.version // "1.0.0"' "$MANIFEST")
          APP_KEY=$(jq -r '.key // .appKey // "app"' "$MANIFEST")
          APP_NAME=$(jq -r '.name // .key // "Axero App"' "$MANIFEST")

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "app_key=$APP_KEY" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Manifest version: $VERSION, App: $APP_NAME ($APP_KEY)"

      - name: Determine release version
        id: version
        run: |
          MANIFEST_VERSION="${{ steps.manifest.outputs.version }}"
          LATEST_VERSION="${{ steps.latest.outputs.version }}"
          BUMP_TYPE="${{ inputs.version_bump }}"
          PRERELEASE_LABEL="${{ inputs.prerelease_label }}"

          echo "Comparing: manifest=$MANIFEST_VERSION vs latest=$LATEST_VERSION"
          echo "Pre-release label: '${PRERELEASE_LABEL}'"

          # Compare versions numerically to check if manifest is ahead of latest release
          version_gt() {
            IFS='.' read -r a1 b1 c1 <<< "$1"
            IFS='.' read -r a2 b2 c2 <<< "$2"
            a1=${a1:-0}; b1=${b1:-0}; c1=${c1:-0}
            a2=${a2:-0}; b2=${b2:-0}; c2=${c2:-0}
            [ "$a1" -gt "$a2" ] && return 0
            [ "$a1" -lt "$a2" ] && return 1
            [ "$b1" -gt "$b2" ] && return 0
            [ "$b1" -lt "$b2" ] && return 1
            [ "$c1" -gt "$c2" ] && return 0
            return 1
          }

          # Handle pre-release versioning first (no auto-bump for pre-releases)
          IS_PRERELEASE="false"
          if [ -n "$PRERELEASE_LABEL" ]; then
            IS_PRERELEASE="true"
            # Pre-releases always use the current manifest version as base (no bump)
            BASE_VERSION="$MANIFEST_VERSION"
            BUMPED="false"

            # Sanitize label: replace special chars with -, lowercase, truncate to 20 chars
            SANITIZED_LABEL=$(echo "$PRERELEASE_LABEL" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]' | cut -c1-20 | sed 's/-$//')

            # Count existing pre-releases with same label to get build number
            BUILD_NUM=$(gh release list --limit 100 --json tagName -q "[.[].tagName | select(contains(\"-${SANITIZED_LABEL}.\"))] | length" 2>/dev/null || echo "0")
            BUILD_NUM=$((BUILD_NUM + 1))

            NEW_VERSION="${BASE_VERSION}-${SANITIZED_LABEL}.${BUILD_NUM}"
            echo "Pre-release version: $NEW_VERSION (base from manifest, no bump)"
          elif version_gt "$MANIFEST_VERSION" "$LATEST_VERSION"; then
            # Manifest version is ahead of latest release - use it directly
            BASE_VERSION="$MANIFEST_VERSION"
            BUMPED="false"
            NEW_VERSION="$BASE_VERSION"
            echo "Using manifest version (manually bumped ahead of latest release)"
          else
            # Auto-bump from latest release version
            IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
            MAJOR=${MAJOR:-0}
            MINOR=${MINOR:-0}
            PATCH=${PATCH:-0}

            case "$BUMP_TYPE" in
              major)
                BASE_VERSION="$((MAJOR + 1)).0.0"
                ;;
              minor)
                BASE_VERSION="$MAJOR.$((MINOR + 1)).0"
                ;;
              *)
                BASE_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                ;;
            esac
            BUMPED="true"
            NEW_VERSION="$BASE_VERSION"
            echo "Auto-bumped: $LATEST_VERSION -> $BASE_VERSION ($BUMP_TYPE)"
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "bumped=$BUMPED" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Update manifest version
        run: |
          APP_PATH="${{ inputs.app_path }}"
          MANIFEST="$APP_PATH/manifest.json"
          NEW_VERSION="${{ steps.version.outputs.version }}"

          jq --arg v "$NEW_VERSION" '.version = $v' "$MANIFEST" > tmp.json && mv tmp.json "$MANIFEST"
          echo "Updated manifest.json to version $NEW_VERSION"

      - name: Download axeroapp CLI
        run: |
          CLI_VERSION="${{ inputs.cli_version }}"
          CLI_REPO="joanlm/axeroapp-cli"

          echo "Downloading axeroapp CLI..."

          if [ "$CLI_VERSION" = "latest" ]; then
            gh release download --repo "$CLI_REPO" --pattern "axeroapp-linux-x64" --dir .
          else
            gh release download "v$CLI_VERSION" --repo "$CLI_REPO" --pattern "axeroapp-linux-x64" --dir .
          fi

          chmod +x axeroapp-linux-x64
          sudo mv axeroapp-linux-x64 /usr/local/bin/axeroapp

          echo "axeroapp CLI installed"
          axeroapp --version 2>/dev/null || echo "(version command not available)"
        env:
          GH_TOKEN: ${{ secrets.cli_token }}

      - name: Build app
        if: ${{ inputs.skip_build != true }}
        run: |
          APP_PATH="${{ inputs.app_path }}"

          echo "Building app..."
          if axeroapp build --path "$APP_PATH" 2>&1; then
            echo "Build completed"
          else
            echo "Build step completed (may have no buildable pages)"
          fi

      - name: Package app
        id: package
        run: |
          APP_PATH="${{ inputs.app_path }}"
          VERSION="${{ steps.version.outputs.version }}"
          APP_KEY="${{ steps.manifest.outputs.app_key }}"

          # Name distinctly to differentiate from auto-generated source archives
          ZIP_NAME="${APP_KEY}-app-package-v${VERSION}.zip"
          echo "Packaging as $ZIP_NAME..."

          # Package outputs to current directory
          axeroapp package --path "$APP_PATH" --output "$ZIP_NAME"

          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT
          ls -la "$ZIP_NAME"

      - name: Commit version bump
        id: commit
        if: steps.version.outputs.bumped == 'true'
        run: |
          APP_PATH="${{ inputs.app_path }}"
          MANIFEST="$APP_PATH/manifest.json"
          NEW_VERSION="${{ steps.version.outputs.version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "$MANIFEST"
          git commit -m "Bump version to $NEW_VERSION [skip ci]"
          git push
          echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "Committed version bump to $NEW_VERSION"

      - name: Create GitHub Release
        id: release
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ZIP_NAME="${{ steps.package.outputs.zip_name }}"
          APP_NAME="${{ steps.manifest.outputs.app_name }}"
          APP_KEY="${{ steps.manifest.outputs.app_key }}"
          COMMIT_SHA="${{ steps.commit.outputs.sha }}"

          # Generate release notes with clear download instructions
          cat > release_notes.md << NOTES
          ## ðŸ“¦ Download

          **Download:** \`$ZIP_NAME\`

          > âš ï¸ **Note:** Ignore the "Source code" archives below - those are auto-generated by GitHub and contain raw source files, not the installable app package.

          ## Installation

          **Via Axero App Manager:**
          1. Go to App Manager â†’ Install App
          2. Select "GitHub Release"
          3. Choose this repository and version

          **Manual:**
          1. Download \`$ZIP_NAME\` above
          2. Go to App Manager â†’ Install App â†’ Upload ZIP
          3. Upload the downloaded file

          ---
          *Built with [axeroapp-workflows](https://github.com/joanlm/axeroapp-workflows)*
          NOTES

          # Create release, targeting the version bump commit if it exists
          TARGET_FLAG=""
          if [ -n "$COMMIT_SHA" ]; then
            TARGET_FLAG="--target $COMMIT_SHA"
          fi

          # Mark as pre-release if applicable
          PRERELEASE_FLAG=""
          IS_PRERELEASE="${{ steps.version.outputs.is_prerelease }}"
          if [ "$IS_PRERELEASE" = "true" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi

          RELEASE_URL=$(gh release create "v$VERSION" \
            "$ZIP_NAME" \
            --title "$APP_NAME v$VERSION" \
            --notes-file release_notes.md \
            $TARGET_FLAG \
            $PRERELEASE_FLAG)

          echo "url=$RELEASE_URL" >> $GITHUB_OUTPUT
          echo "::notice::Release created: $RELEASE_URL"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          APP_NAME="${{ steps.manifest.outputs.app_name }}"
          RELEASE_URL="${{ steps.release.outputs.url }}"

          echo "## ðŸš€ Release Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**App:** $APP_NAME" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** v$VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Release:** $RELEASE_URL" >> $GITHUB_STEP_SUMMARY
